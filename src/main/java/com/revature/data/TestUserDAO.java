package com.revature.data;

import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.List;

import com.revature.pojos.TestUser;
import com.revature.util.ConnectionFactory;

/*
 * The DAO(Data Access Object) should be the only place where a connection is made to 
 * the database. Design pattern allows for separation of concerns and cleaner code.
 * Data Access Object for DAO layer - typically this would be implemented as
 * an interface that can be implemented depending on how we're accessing our data
 * --Only has persistence logic - create/update/delete
 * ----Service Layer will actually apply some business logic
 * 
 * JDBC - Java Database Connectivity
 * 
 */
public class TestUserDAO {

	/*
	 * STATEMENT - interface in JDBC API that
	 * takes SQL statement as string and executes it, returning the result.
	 * 
	 * Exposes to SQL injection - common hacking technique, insertion of code
	 * as input sent to DB
	 */
	
	
			
		public List<TestUser> getUsers(){ 	//not including throw because we don;t want to propagate
										//exception caught below
			List<TestUser> users = new ArrayList<TestUser>();
			
				//Connection implements auto-closable interface so can be instantiated in
				//try-with-resources block
			try(Connection conn = ConnectionFactory.getInstance().getConnection()){
				String query= "select * from demo_user"; //copy-paste from SQL
				
				//STATEMENT INTERFACE
				Statement statement = conn.createStatement();
				
				//RESULTSET interface - represent set of results of a DB query
				ResultSet rs = statement.executeQuery(query);
				
				while (rs.next()) {
					TestUser temp = new TestUser(
							//can get by index based on ordering in DB table or by identifier
							 rs.getInt(1),
							 rs.getString("USERNAME"),
							 rs.getString(3),
							 rs.getString("BIO"));
					 users.add(temp);
				 }
				//rs.close(); assuming they get closed when connection gets closed
				
			}catch(SQLException e) {
				e.printStackTrace();
			}
			return users;
		}
		
		/*
		 * Prepared Statements: more secure than general statements, re-usable
		 */
		
		public TestUser getByUsername(String username) {
			TestUser u = null;
			try(Connection conn = ConnectionFactory.getInstance().getConnection()){  				//any resource that allots memory elsewhere or utilizes tools elsewhere -> must close
				String sql = "select * from demo_user\r\n" + 
						"where lower(username) = ?"; //stating that username will be some variable we will feed in 
													 // '?'s / variables are set by index, starting with 0
				
				PreparedStatement ps = conn.prepareStatement(sql); //regardless of what is put in '?', it doesn't matter. Will execute query as-is
				ps.setString(1,  username.toLowerCase()); //generally adjust cases to ensure uniform data format
				ResultSet rs = ps.executeQuery(); 		//getting output of above query into rs; and ps has query inside it as embedded above
				
				//utilize data in rs for desired output -> when we first get rs back, it points above the first row
				
				//if rs is not false(null), proceed to see our first user
				if(rs.next()) { 			//instead of looping through all rows, we're going through the first
											//and in this case we don't want multiple rows of a user that matches this username
					 u = new TestUser(
							//can get by index based on ordering in DB table or by identifier
							 rs.getInt(1),
							 rs.getString("USERNAME"),
							 rs.getString(3),
							 rs.getString("BIO"));
				}
				
			} catch (SQLException e) {
				e.printStackTrace();
			}
			return u;
		}
		
		/*
		 * Prepared statement to execute UPDATE
		 * Our DB has sequence to auto-increment, we want our update to return the ID of the user that was added, because
		 * their ID was automatically generated
		 */
		public TestUser addUser(TestUser u) {
			try(Connection conn = ConnectionFactory.getInstance().getConnection()){
				//conn.setAutoCommit(); is set to true
				
				String sql = "insert into demo_user(username, password, bio)" + 
						"values(?, ? , ?)";
				String[] keyNames = {"u_id"}; 				//list of auto-generated keys, specify column names
				
				PreparedStatement ps = conn.prepareStatement(sql, keyNames);				//Prepared Statement overloaded
															//if we want primary key (autogenerated key) after update, must use one of these functions
				ps.setString(1, u.getUsername());	//'?'s above
				ps.setString(2, u.getPassword());
				ps.setString(3, u.getBio());
				
				int numRowsAffected = ps.executeUpdate(); //don't need to set the executeUpdate to anything unless using num rows affected
				
				System.out.println("ADDED" + numRowsAffected + "USER(S) TO DB");
				
				if(numRowsAffected ==1) {
					ResultSet pk = ps.getGeneratedKeys(); 	//result set of primary key
					pk.next();
					u.setId(pk.getInt(1));
				}
			}catch(SQLException e) {
				e.printStackTrace();
			}
			return u;
		}
}
